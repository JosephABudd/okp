/// This channel dispatches the "add" message to it's subscribers.
/// Any messenger can send an "add" message by calling .send.
/// This file was generated by kickzig when you added the "add" message.
/// It will be removed when you remove the "add" message.
/// DO NOT EDIT THIS FILE.
const std = @import("std");

pub const _message_ = @import("message").add;

/// Behavior is call-backs and state.
/// .receiveFn is a call-back, a function that receives the message.
/// .self is the state required for the call-back. It is the implementor of the recieveFn.
pub const Behavior = struct {
    receiveFn: *const fn (self: *anyopaque, message: *_message_.Message) void,
    self: *anyopaque,
};

pub const Group = struct {
    allocator: std.mem.Allocator = undefined,
    members: std.AutoHashMap(*anyopaque, *Behavior),

    /// initBehavior constructs an empty Behavior.
    pub fn initBehavior(self: *Group) !*Behavior {
        return self.allocator.create(Behavior);
    }

    pub fn deinit(self: *Group) void {
        self.members.deinit();
        self.allocator.destroy(self);
    }

    /// subscribe adds a receiver of the message to the Group.
    /// The receiver must implement Behavior.
    pub fn subscribe(self: *Group, cb: *Behavior) !void {
        try self.members.put(cb.self, cb);
    }

    /// unsubscribe removes a subscriber from the Group.
    /// Returns true if anything was removed.
    pub fn unsubscribe(self: *Group, caller: *anyopaque) bool {
        if (self.members.getEntry(caller)) |entry| {
            var behavior: *Behavior = @ptrCast(entry.value_ptr.*);
            self.allocator.destroy(behavior);
            return self.members.remove(caller);
        }
    }

    /// send dispatches the message to the subscribers in Group.
    /// It takes control of the message and deinits it.
    /// Receivers can safely resend the same message.
    pub fn send(self: *Group, message: *_message_.Message) !void {
        return self.dispatchThread(message);
    }

    fn dispatchThread(self: *Group, message: *_message_.Message) !void {
        std.debug.print("dispath has {d} receivers.\n", .{self.members.count()});
        var thread = try std.Thread.spawn(.{ .allocator = self.allocator }, dispatchDeinit, .{ self.members, message });
        std.Thread.detach(thread);
    }

    fn dispatchNoThread(self: *Group, message: *_message_.Message) !void {
        dispatchDeinit(self.members, message);
    }
};

pub fn init(allocator: std.mem.Allocator) !*Group {
    var channel: *Group = try allocator.create(Group);
    channel.allocator = allocator;
    channel.members = std.AutoHashMap(*anyopaque, *Behavior).init(allocator);
    errdefer {
        allocator.destroy(channel);
    }
    return channel;
}

fn dispatchDeinit(members: std.AutoHashMap(*anyopaque, *Behavior), message: *_message_.Message) void {
    defer message.deinit();
    var iterator = members.iterator();
    while (iterator.next()) |entry| {
        var behavior: *Behavior = entry.value_ptr.*;
        behavior.receiveFn(behavior.self, message);
    }
}
