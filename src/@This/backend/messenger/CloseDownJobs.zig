/// This is the back-end's "CloseDownJobs" message handler.
/// This messenger can receive the "CloseDownJobs" message from the front-end
///     and then as needed, send the "CloseDownJobs" message back to the front-end.
/// The "CloseDownJobs" message is at deps/message/src/CloseDownJobs.zig.
/// This file was generated by kickzig when you added the "CloseDownJobs" message.
/// This file will be removed by kickzig when you remove the "CloseDownJobs" message.
/// KICKZIG TODO: Customize fn receiveFn.
const std = @import("std");

const _channel_ = @import("channel");
const _message_ = @import("message");
const _startup_ = @import("startup");

pub const Messenger = struct {
    allocator: std.mem.Allocator,
    send_channels: *_channel_.BackendToFrontend,
    receive_channels: *_channel_.FrontendToBackend,

    pub fn deinit(self: *Messenger) void {
        self.allocator.destroy(self);
    }

    /// receiveCloseDownJobsFn receives the "CloseDownJobs" message from the front-end.
    /// It implements _channel_.FrontendToBackend.CloseDownJobs.Behavior.receiveFn found in deps/channel/fronttoback/CloseDownJobs.zig.
    /// The receiveCloseDownJobsFn owns the message it receives.
    pub fn receiveCloseDownJobsFn(implementor: *anyopaque, message: *_message_.CloseDownJobs.Message) anyerror!void {
        var self: *Messenger = @alignCast(@ptrCast(implementor));
        defer message.deinit();

        self.do(message) catch |err| {
            // Fatal error.
            std.log.debug("BE CloseDownJobs messenger.receiveCloseDownJobsFn receiveJob: {s}", .{@errorName(err)});
            return err;
        };
    }

    /// do fullfills the front-end's request.
    /// Returns nothing or an error.
    /// KICKZIG TODO: Add the required functionality.
    fn do(self: *Messenger, message: *_message_.CloseDownJobs.Message) !void {
        if (message.frontend_payload.jobs) |jobs| {
            // Pass the jobs to do.
            const last = jobs.len - 1;
            const last_f32: f32 = @as(f32, @floatFromInt(jobs.len));
            var current_f32: f32 = 0.0;
            for (jobs, 0..) |job, i| {
                current_f32 += 1.0;
                job.job(job.implementor);
                var return_message: *_message_.CloseDownJobs.Message = try _message_.CloseDownJobs.init(self.allocator);
                var status_update: []u8 = try std.fmt.allocPrint(self.allocator, "Finishing up. Completed {d} of {d} jobs.", .{ (i + 1), jobs.len });
                defer self.allocator.free(status_update);
                try return_message.backend_payload.set(.{
                    .status_update = status_update,
                    .completed = (i < last),
                    .progress = current_f32 / last_f32,
                });
                try self.send_channels.CloseDownJobs.send(return_message);
            }
        } else {
            // No jobs so were done.
            var return_message = try message.copy();
            try return_message.backend_payload.set(.{ .completed = true, .status_update = "Completed.", .progress = 0.0 });
            try self.send_channels.CloseDownJobs.send(return_message);
        }
    }
};

pub fn init(startup: _startup_.Backend) !*Messenger {
    var messenger: *Messenger = try startup.allocator.create(Messenger);
    messenger.allocator = startup.allocator;
    messenger.send_channels = startup.send_channels;
    messenger.receive_channels = startup.receive_channels;
    var receive_behavior = try startup.receive_channels.CloseDownJobs.initBehavior();
    errdefer {
        messenger.deinit();
    }
    receive_behavior.implementor = messenger;
    receive_behavior.receiveFn = &Messenger.receiveCloseDownJobsFn;
    try startup.receive_channels.CloseDownJobs.subscribe(receive_behavior);
    errdefer {
        messenger.deinit();
    }
    return messenger;
}