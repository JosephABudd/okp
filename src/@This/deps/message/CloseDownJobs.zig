/// This file was generated by kickzig when you created the framework.
/// This file will be never be touched by kickzig.
/// The "CloseDownJobs" message is:
/// * sent from the front-end to the back-end
/// * with the back-end possibly returning the message back to the front-end.
/// The front-end will:
/// 1. init this message.
/// 2. set the front-end payload with the list of jobs.
/// 3. send the message to the back-end.
/// The back-end will:
/// 1. receive the message.
/// 2. run each job and after each job:
///    i.   make a new message.
///    ii.  set the back-end payload:
///         .done = false or true if last job;
///         .status = some text.
///    iii. send the new message back to the front-end.
/// The front-end upon receiving the returned message:
///    i.  will process the data in the back-end payload.
///    ii. WILL NOT RETURN THE MESSAGE TO THE BACK-END.
const std = @import("std");
const Counter = @import("counter").Counter;
const _closedownjobs_ = @import("closedownjobs");

// FrontendPayload is the "CloseDownJobs" message from the front-end to the back-end.
pub const FrontendPayload = struct {
    allocator: std.mem.Allocator,
    is_set: bool,

    // Each close down job.
    jobs: ?[]const *_closedownjobs_.Job,

    pub const Settings = struct {
        jobs: ?[]const *_closedownjobs_.Job,
    };

    fn init(allocator: std.mem.Allocator) !*FrontendPayload {
        var self: *FrontendPayload = try allocator.create(FrontendPayload);
        self.allocator = allocator;
        self.is_set = false;
        self.jobs = null;
        return self;
    }

    fn deinit(self: *FrontendPayload) void {
        if (self.jobs) |jobs| {
            for (jobs) |job| {
                job.deinit();
            }
            self.allocator.free(jobs);
        }
        self.allocator.destroy(self);
    }

    // Returns an error if already set.
    pub fn set(self: *FrontendPayload, values: Settings) !void {
        if (self.is_set) {
            return error.CloseDownJobsFrontendPayloadAlreadySet;
        }
        self.is_set = true;
        if (values.jobs) |jobs| {
            self.jobs = try self.allocator.alloc(*_closedownjobs_.Job, jobs.len);
            for (jobs, 0..) |job, i| {
                @constCast(self.jobs.?)[i] = try job.copy();
            }
        }
    }
};

// BackendPayload is the "CloseDownJobs" message from the back-end to the front-end.
pub const BackendPayload = struct {
    allocator: std.mem.Allocator = undefined,
    is_set: bool,

    // The member status_update is the current status of the operation.
    status_update: ?[]const u8,
    completed: bool,
    progress: f32,

    pub const Settings = struct {
        status_update: ?[]const u8,
        completed: ?bool,
        progress: ?f32,
    };

    fn init(allocator: std.mem.Allocator) !*BackendPayload {
        var self: *BackendPayload = try allocator.create(BackendPayload);
        self.allocator = allocator;
        self.is_set = false;
        self.status_update = null;
        self.progress = 0.0;
        self.completed = false;
        return self;
    }

    fn deinit(self: *BackendPayload) void {
        if (self.status_update) |status_update| {
            self.allocator.free(status_update);
        }
        self.allocator.destroy(self);
    }

    // Returns an error if already set.
    pub fn set(self: *BackendPayload, values: Settings) !void {
        if (self.is_set) {
            return error.CloseDownJobsBackendPayloadAlreadySet;
        }
        self.is_set = true;
        if (values.status_update) |status_update| {
            self.status_update = try self.allocator.alloc(u8, status_update.len);
            @memcpy(@constCast(self.status_update), status_update);
        }
        if (values.completed) |completed| {
            self.completed = completed;
        }
        if (values.progress) |progress| {
            self.progress = progress;
        }
    }
};

/// This is the "CloseDownJobs" message.
pub const Message = struct {
    allocator: std.mem.Allocator,
    count_pointers: *Counter,
    frontend_payload: *FrontendPayload,
    backend_payload: *BackendPayload,

    // deinit does not deinit until self is the final pointer to Message.
    pub fn deinit(self: *Message) void {
        if (self.count_pointers.dec() > 0) {
            // There are more pointers.
            // See fn copy.
            return;
        }
        // This is the last existing pointer.
        self.count_pointers.deinit();
        self.allocator.destroy(self);
    }

    /// KICKZIG TODO:
    /// copy pretends to create and return a copy of the message.
    /// The dispatcher sends a copy to each receiveFn.
    /// Each receiveFn owns the message copy and must deinit it.
    /// The back-end receiveFn must only send a copy to the front-end.
    /// Back-end Messenger Example:
    /// var return_copy = message.copy() catch |err| {
    ///     self.exit(@src(), err, "message.copy()");
    /// };
    /// // Set the back-end payload.
    /// return_copy.backend_payload.set(.{.name = record.name}) catch |err| {
    ///     self.exit(@src(), err, "return_copy.backend_payload.set(.{.name = record.name})");
    /// };
    /// // Send the message copy to the front-end.
    /// // The channel's send function owns the copy and will deinit it.
    /// self.send_channels.CloseDownJobs.send(message) catch |err| {
    ///     self.exit(@src(), err, "self.send_channels.CloseDownJobs.send(message)");
    /// };
    ///
    /// In this case copy does not return a copy of itself.
    /// In order to save memory space, it really only
    /// * increments the count of the number of pointers to this message.
    /// * returns self.
    /// See deinit().
    pub fn copy(self: *Message) !*Message {
        _ = self.count_pointers.inc();
        return self;
    }
};

/// init creates an original message.
pub fn init(allocator: std.mem.Allocator) !*Message {
    var self: *Message = try allocator.create(Message);
    self.frontend_payload = try FrontendPayload.init(allocator);
    errdefer {
        allocator.destroy(self);
    }
    self.backend_payload = try BackendPayload.init(allocator);
    errdefer {
        self.frontend_payload.deinit();
        allocator.destroy(self);
    }
    self.count_pointers = try Counter.init(allocator);
    errdefer {
        self.backend_payload.deinit();
        self.frontend_payload.deinit();
        allocator.destroy(self);
    }
    _ = self.count_pointers.inc();
    self.allocator = allocator;
    return self;
}